use super::OsError;
use std::ffi::{c_void, OsStr, OsString};
use std::os::windows::ffi::OsStringExt;
use std::os::windows::prelude::OsStrExt;
use std::ptr;

use winapi::shared::ntdef::{LANG_NEUTRAL, MAKELANGID, SUBLANG_DEFAULT};
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::fileapi::ReadFile;
use winapi::um::minwinbase::{OVERLAPPED_u, OVERLAPPED};
use winapi::um::winbase::FormatMessageW;
use winapi::um::winbase::{FORMAT_MESSAGE_FROM_SYSTEM, FORMAT_MESSAGE_IGNORE_INSERTS};

/// Extension to make calling winapi methods easier
pub trait WinapiExt<T>
where
    Self: Sized,
{
    /// Call a winapi method, automatically handling buffer allocation and conversion
    ///
    /// # Arguments
    ///
    /// * `size` - The size (in terms of T) of the allocated buffer
    /// * `f` - A closure which contains the function to call, this is passed the `size` along with a pointer to the buffer
    /// * `ok` - A closure which takes the return value of `f` and computes whether it was a success
    /// * `truncate` - Whether to truncate the returned buffer at the first last null byte
    ///
    /// # Returns
    ///
    /// The type specified by the trait implementation generated by the buffer if the function was a success.
    /// Otherwise, [get_last_error] is called and the value is returned as an Err().
    fn call<F, R, V>(size: usize, f: F, ok: V, truncate: bool) -> Result<Self, OsError>
    where
        F: FnOnce(usize, *mut T) -> R,
        V: FnOnce(R) -> bool;
}

impl WinapiExt<u8> for Vec<u8> {
    fn call<F, R, V>(size: usize, f: F, ok: V, truncate: bool) -> Result<Self, OsError>
    where
        F: FnOnce(usize, *mut u8) -> R,
        V: FnOnce(R) -> bool,
    {
        let mut buffer: Vec<u8> = Vec::with_capacity(size);

        let status = f(size, buffer.as_mut_ptr());

        if ok(status) {
            unsafe { buffer.set_len(size) }

            if truncate {
                // Remove any data after the first null byte
                buffer.truncate(buffer.iter().position(|c| c == &0).unwrap_or(buffer.len()));
            }

            Ok(buffer)
        } else {
            Err(get_last_error().into())
        }
    }
}

impl WinapiExt<u16> for Vec<u16> {
    fn call<F, R, V>(size: usize, f: F, ok: V, truncate: bool) -> Result<Self, OsError>
    where
        F: FnOnce(usize, *mut u16) -> R,
        V: FnOnce(R) -> bool,
    {
        let mut buffer: Vec<u16> = Vec::with_capacity(size);

        let status = f(size, buffer.as_mut_ptr());

        if ok(status) {
            unsafe { buffer.set_len(size) }

            if truncate {
                // Remove any data after the first null byte
                buffer.truncate(buffer.iter().position(|c| c == &0).unwrap_or(buffer.len()));
            }

            Ok(buffer)
        } else {
            Err(get_last_error().into())
        }
    }
}

impl WinapiExt<u8> for String {
    fn call<F, R, V>(size: usize, f: F, ok: V, truncate: bool) -> Result<Self, OsError>
    where
        F: FnOnce(usize, *mut u8) -> R,
        V: FnOnce(R) -> bool,
    {
        let raw: Vec<u8> = WinapiExt::call(size, f, ok, truncate)?;
        String::from_utf8(raw).map_err(|_| "attempted to convert non utf-8 buffer to utf-8".into())
    }
}

impl WinapiExt<u16> for OsString {
    fn call<F, R, V>(size: usize, f: F, ok: V, truncate: bool) -> Result<Self, OsError>
    where
        F: FnOnce(usize, *mut u16) -> R,
        V: FnOnce(R) -> bool,
    {
        let raw: Vec<u16> = WinapiExt::call(size, f, ok, truncate)?;
        Ok(OsString::from_wide(&raw))
    }
}

/// Convert a rust string into an LPCWSTR
///
/// # Arguments
///
/// * `s` - The string to convert
///
/// # Safety
///
/// The caller must ensure that the input string outlives the returned pointer.
///
/// # Examples
///
/// ```
/// # use std::ffi::OsString;
/// let s = String::from("Hello, World!");
/// unsafe {
///     let ptr: *const u16 = to_lpcwstr(&s);
///     assert_eq!(*ptr, s.bytes().next().unwrap() as u16);
/// }
/// ```
pub unsafe fn to_lpcwstr<S>(s: S) -> *const u16
where
    S: AsRef<OsStr>,
{
    let mut bytes = OsStr::new(s.as_ref())
        .encode_wide()
        .chain(::std::iter::once(0))
        .collect::<Vec<u16>>();

    // Insert a null byte
    bytes.push(0);
    bytes.as_ptr()
}

/// Read bytes from a file handle
pub unsafe fn read_file(
    file: *mut c_void,
    size: usize,
    offset: Option<u32>,
) -> Result<Vec<u8>, OsError> {
    let mut read = 0;

    let mut data: Vec<u8> = WinapiExt::call(
        size,
        |size, data| unsafe {
            ReadFile(
                file,
                data as *mut c_void,
                size as u32,
                &mut read,
                match offset {
                    Some(offset) => {
                        let mut u = OVERLAPPED_u::default();
                        u.s_mut().Offset = offset;
                        &mut OVERLAPPED {
                            u,
                            hEvent: ptr::null_mut(),
                            Internal: 0,
                            InternalHigh: 0,
                        }
                    }
                    None => ptr::null_mut(),
                },
            )
        },
        |status| status != 0,
        false,
    )?;

    data.set_len(read as usize);

    Ok(data)
}

/// Get the error message of the last winapi error using `GetLastError` and `FormatMessage`
pub fn get_last_error() -> OsString {
    let code = unsafe { GetLastError() };

    const BUFFER_SIZE: u32 = 16384; // 16kb (just in case)
    let mut buffer: Vec<u16> = Vec::with_capacity(BUFFER_SIZE as usize);

    let size = unsafe {
        FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            ptr::null(),
            code,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT).into(),
            buffer.as_mut_ptr(),
            BUFFER_SIZE,
            ptr::null_mut(),
        )
    };

    unsafe { buffer.set_len(size as usize) }

    // If FormatMessage failed then inject our own error message
    if size == 0 {
        OsString::from("`FormatMessage` unexpectedly failed to fetch error status, this is likely a bug or a problem with your system")
    } else {
        OsString::from_wide(&buffer)
    }
}

/// Cast a pointer into another type
///
/// This method is **extraordinarily** unsafe and several conditions must be met before calling it.
/// - The pointer must be properly aligned
/// - The pointer must point to an initialized instance of the target
///
/// Note that **is is up to the caller** to ensure that the data the pointer is targeting outlives the returned object.
pub trait PtrCast {
    /// Perform the cast
    unsafe fn cast<U>(self) -> &'static U;
}

impl PtrCast for *const u8 {
    unsafe fn cast<U>(self) -> &'static U {
        (self as *const U).as_ref().unwrap()
    }
}

/// Cast a mutable pointer into another type
///
/// This is the mutable version of the [PtrCast] method.
pub trait PtrMutCast {
    /// Perform the cast
    unsafe fn cast<U>(self) -> &'static mut U;
}

impl PtrMutCast for *mut u8 {
    unsafe fn cast<U>(self) -> &'static mut U {
        (self as *mut U).as_mut().unwrap()
    }
}
